{"bi-ji-zhuan-qu.html":{"url":"bi-ji-zhuan-qu.html","title":"1 笔记专区","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-08-20 06:33:46 "},"ji-he-xue-xi.html":{"url":"ji-he-xue-xi.html","title":"1.1 集合源码学习","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/list.html":{"url":"ji-he-xue-xi/list.html","title":"List","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/arraylist.html":{"url":"ji-he-xue-xi/arraylist.html","title":"ArrayList","keywords":"","body":"我们知道，ArrayList的结构是数组，一般在程序中这样使用ArrayList arrayList = new ArrayList<>(); arrayList.add(\"AA\"); arrayList.add(\"BB\"); arrayList.add(\"CC\"); arrayList.get(0); 接下来我们先看一下ArrayList的属性再来一行一行来阅读源码。该类 定义了两个空的Object数组，两个int类型变量，一个为null的临时Object数组； public ArrayList() { //构造器中将一个空的object数组赋值给临时的elementData对象； this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(int initialCapacity) { if (initialCapacity > 0) { //如果大于0的话，elementData初始化一个Object数组，大小为传入的值的大小。 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { //如果等于0的话，elementData就为一个空的数组； this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } //数组添加第一个对象 public boolean add(E e) { //这里是扩容方法 ensureCapacityInternal(size + 1); // Increments modCount!! //这里可以分解为两步 //elementData[size] = e; // ++size elementData[size++] = e; return true; } private void ensureCapacityInternal(int minCapacity) { //如果elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 说明是调用的无参构造器。 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } //minCapacity可以理解为需要完成这次add所需要的最小容量。 ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; //如果 elementData.length 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code //获取旧的数组的长度 int oldCapacity = elementData.length; //新的长度 = old + (int)(old/2) int newCapacity = oldCapacity + (oldCapacity >> 1); //如果计算出来的新的容量小于所需的最小容量的话新的就被赋值为所需的最小容量。 if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); //重新创建一个新容量的数组将旧的数组内容copy进来并赋值给当前list数组。 elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 1.初始化时 ： 数组为{} 因此数组长度为0；2.第一次调用add时，我需要的数组容量为1，此时数组的长度为0 因此需要扩容操作，第一次扩容出来的长度为默认值10;3.当第11次调用add方法时 需要的容量为11 此时就会进入扩容操作，新的容量为 10 + (int)(10/2) = 15;4.get方法获取指定数组下标的值； public E get(int index) { rangeCheck(index); return elementData(index); } private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } //移除操作 public E remove(int index) { rangeCheck(index); modCount++; //获取旧的值 E oldValue = elementData(index); //如果index+1 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 总结：ArrayList 第一次扩容的初始化大小为10,扩容策略为 旧值 + (int)(旧值/2),在使用ArratList的时候指定合适的容量可以减少扩容次数；第一次初始化数组长度为10;第一次扩容操作数组长度为15;Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2019-08-13 03:37:21 "},"ji-he-xue-xi/vector.html":{"url":"ji-he-xue-xi/vector.html","title":"Vector","keywords":"","body":" //一般在程序中我们这样使用vector List vector = new Vector<>(); vector.add(\"SS\"); vector.add(\"DD\"); vector.add(\"FF\"); vector.get(2); public Vector() { this(10); } public Vector(int initialCapacity) { this(initialCapacity, 0); } public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity 0) grow(minCapacity); } private void grow(int minCapacity) { //获取旧的数组长度 int oldCapacity = elementData.length; //扩容策略为。增长长度大于0的话就为旧的长度添加增长长度。否则扩大为原来的2倍； int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/linkedlist.html":{"url":"ji-he-xue-xi/linkedlist.html","title":"LinkedList","keywords":"","body":"上边的是LinkedList 的类结构图。LinkedList一般我们在程序中这样使用LinkedList linkedList = new LinkedList<>(); linkedList.add(\"AA\"); linkedList.add(\"BB\"); linkedList.get(0); //先看一下LinkedList的无参构造器 public LinkedList() { //无参构造器里无操作 } public boolean add(E e) { //调用add方法，进入linkLast方法 linkLast(e); return true; } void linkLast(E e) { //将last的值赋值给l，这里第一次调用add的话l的值为null； final Node l = last; //将add的元素封装为一个Node，这里新的Node的item为当前元素，下一个为null，上一个为LinkedList的last元素，当然初始为null; final Node newNode = new Node<>(l, e, null); //更新LinkedList对象的last的值为新元素封装成的Node; last = newNode; //如果l为null，说明是第一次添加元素，那么LinkedList的first属性就为刚才新的Node; if (l == null) first = newNode; //如果不为null，那么说明当前的last的下一个就是新元素的Node; else l.next = newNode; size++; modCount++; } Node(Node prev, E element, Node next) { this.item = element; this.next = next; this.prev = prev; } public E get(int index) { //先检查指定索引 checkElementIndex(index); return node(index).item; } Node node(int index) { //如果需要查找的索引位置位于前半部分则从头部开始往后找，如果位于后半部分则从尾部往前找 if (index > 1)) { Node x = first; for (int i = 0; i x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } //移除操作 public E remove(int index) { checkElementIndex(index); //先获取指定索引的Node节点 return unlink(node(index)); } E unlink(Node x) { // final E element = x.item; final Node next = x.next; final Node prev = x.prev; //如果前一个为null说明是移除的是头部节点； if (prev == null) { //更新集合的first节点为移除的下一个 first = next; } else { //不为头部节点，被移除节点的前一个的下一个更新为当前节点的下一个；被移除节点的前一个置为null prev.next = next; x.prev = null; } //如果next为null，说明移除的是尾部节点，然后更新集合的最后节点 if (next == null) { last = prev; } else { //不为尾部节点，移除节点的下一个的上一个更新为移除节点的上一个 next.prev = prev; x.next = null; } //size减一操作，操作次数累加 x.item = null; size--; modCount++; return element; } 1.LinkedList 内部维护了一个双向链表，head和last分别为链表的头部和尾部； 2.LinkedList 查找指定索引的元素效率低，是因为需要从first节点开始往后遍历或者需要从last往前遍历； 3.LinkedList 移除元素要比ArrayList要快因为只用更新被移除节点的前一个节点的下一个引用，以及下一个节点的上一个引用；Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/stack.html":{"url":"ji-he-xue-xi/stack.html","title":"Stack","keywords":"","body":"Stack extends Vector Stack 是集成自Vector;因此它具有Vector的全部属性; @Test public void main1(){ Stack stack = new Stack<>(); //向栈中压入元素 stack.push(\"AA\"); stack.push(\"BB\"); stack.push(\"CC\"); //peek函数是从查看栈顶元素，但是不删除 System.out.println(stack.peek());//CC //pop函数是移除并获取到栈顶元素 //search是查找一个元素在Stack中的index System.out.println(stack.search(\"CC\"));//1 } //向栈内添加元素 public E push(E item) { addElement(item); return item; } //初始化完elementCount的值0; public synchronized void addElement(E obj) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; } private void ensureCapacityHelper(int minCapacity) { // 如果完成本次push所需的空间小于存放元素数组的长度就需要进行扩容 if (minCapacity - elementData.length > 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } public synchronized E peek() { //获取元素的数量; int len = size(); if (len == 0) throw new EmptyStackException(); //栈顶的元素的索引也就是元素数量的最后一个值-1 return elementAt(len - 1); } public synchronized int search(Object o) { //获取元素的索引，例子中CC的索引为2，size是元素的数量，所以结果为1;也就说明Stack的元素栈顶是1，栈底的索引是元素的数量； int i = lastIndexOf(o); if (i >= 0) { return size() - i; } return -1; } public synchronized E pop() { E obj; // 获取元素数量 int len = size(); //获取栈顶元素 obj = peek(); 移除指定索引的元素，一般就是数组的最后一个元素 removeElementAt(len - 1); return obj; } public synchronized void removeElementAt(int index) { modCount++; if (index >= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount); } else if (index 0) { System.arraycopy(elementData, index + 1, elementData, index, j); } elementCount--; elementData[elementCount] = null; /* to let gc do its work */ } Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/map.html":{"url":"ji-he-xue-xi/map.html","title":"Map","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/map/hashmap.html":{"url":"ji-he-xue-xi/map/hashmap.html","title":"HashMap","keywords":"","body":"@Test public void main2(){ Map hashMap = new HashMap<>(); hashMap.put(\"AA\", \"AA\"); hashMap.put(\"BB\", \"BB\"); hashMap.get(\"\"); } 1.table是一个Node类型的数组，Node的属性在下图；2.size是已存放元素的数量3.loadFactor是负载因子4.entrySet是一个泛型为Entry的集合//下边是HashMap中几个固定的静态常量值 static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int MAXIMUM_CAPACITY = 1 >> 16) //首先获取hash的低16位，再与本身做异或运算。 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; //如果table == null 或者 table的长度为0，则需要对table做初始化操作， //n为初始化操作完成后的table的长度； if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //根据(length - 1) & hash 求出这个key在当前数组的存放位置，也就是下标； if ((p = tab[i = (n - 1) & hash]) == null) //如果当前位置为null,那么直接存放在当前位置 tab[i] = newNode(hash, key, value, null); //如果计算出来的当前位置不为null，说明发生了碰撞; else { Node e; K k; //如果原来的key的hash值和新的hash值一样,并且==方法或者equals为true时e为旧的Node对象 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode){如果当前节点是红黑树那么就需要向红黑树添加节点； e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); }else { //如果p既不相等，也不属于红黑树，那么就是链表了，就需要往链表添加一个节点； for (int binCount = 0; ; ++binCount) { //这里的p指的是发生碰撞索引下的旧的Node。 //从第一个开始，找到next为null的节点 if ((e = p.next) == null) { //将新的Node放入到链表的尾部 p.next = newNode(hash, key, value, null); //如果链表的长度 大于等于8的话，就变成红黑树存储； if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //这里链表的每一个都需要和当前key进行hash方法和equals方法进行判断，如果相同的话直接跳出循环; if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; 如果不相同的话p更新为链表的下一个值，再进行下一次循环; p = e; } } //如果e不为null，说明e是已存在的key，这里只需将旧的value替换为新的value即可； if (e != null) { // existing mapping for key V oldValue = e.value; //onlyIfAbsent恒为true; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; 这里如果添加完元素后，元素的数量 大于临界值的话就需要扩容; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } //扩容方法; final Node[] resize() { Node[] oldTab = table; //旧的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧的临界值 int oldThr = threshold; //新的容量和新的临界值 int newCap, newThr = 0; //先看第一个if ，如果旧的容量大于0的话就需要在原来的基础上进行扩容 if (oldCap > 0) { //如果旧的容量大于等于 1 = MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } //如果旧的容量扩大两倍小于1 = DEFAULT_INITIAL_CAPACITY) newThr = oldThr 0){ newCap = oldThr; }else { //这里是调用第一次put时进入的判断，这里新的容量为默认值16；新的临界值为(int)(10*0.75) 也就是12; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; //这里Map的table属性有了值; table = newTab; if (oldTab != null) { for (int j = 0; j e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode)e).split(this, newTab, j, oldCap); else { // preserve order Node loHead = null, loTail = null; Node hiHead = null, hiTail = null; Node next; do { next = e.next; if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } //接下来我们再分析一下满足扩容条件时的扩容方法 final Node[] resize() { //旧的数组; Node[] oldTab = table; //旧的数组的容量; int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧的负载因素; int oldThr = threshold; //新的数组容量，新的负载因素; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } //这里新的容量为原来容量的2倍，新的负载因素也是原来负载因素的2倍； else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) newThr = oldThr 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; table = newTab; //如果旧的数组不为null; if (oldTab != null) { for (int j = 0; j e; //遍历旧的数组，如果当前位置不为null，取出当前位置的值，然后置为null if ((e = oldTab[j]) != null) { oldTab[j] = null; //如果当前位置的元素没有形成链表或者树，直接重新计算在新的数组的下标值，并赋值； if (e.next == null) newTab[e.hash & (newCap - 1)] = e; //如果当前位置的节点是红黑树的话执行split; else if (e instanceof TreeNode) ((TreeNode)e).split(this, newTab, j, oldCap); else { //如果当前位置是链表的话 Node loHead = null, loTail = null; Node hiHead = null, hiTail = null; Node next; do { next = e.next; //这里求出最高位，如果是0的话就还是放到原来的位置； if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } //如果是1的话，就放到原来的索引+旧表长度的位置； else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 我们总结一下这里边涉及到的算法分析；hash = key.hashCode()^(key.hashCode() >>> 16); index = hash & (table.length -1) 这里解释一下为什么我们选取数组的长度时选择2的正次幂，因为数组的长度 -1 相当于一个低位掩码， 高位全部为0，低位全部为1. 相当于保留hash的低位，计算后用来作为数组的下标。因此为了减少碰撞低位尽可能随机。 获取hash的值以后，拿高16位和原始的低16位做异或运算，结果是高16位保持不变，低16位也有了高16位的特征。 private static final int tableSizeFor(int c) { int n = c - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 2.在进行除了首次以外的扩容方法时照道理，我在resize的时候，遍历所有的Node节点，获取他们的hash属性在于新的数组进行求与，重新计算数组下标。 但是如果是链表的话，说明它们的下标索引是相同的。因为扩容是原来的2倍 length - 1 就是在高位添加一个1； 0101 -> 5 00101 -> 5 10101 -> 16 + 5 = 21也就是说如果原来的hash高1位为0时，和新的数组大小求余以后取得的索引不变。 高1位为1时，新的索引位置应该是原来的索引位置+旧的数组长度。 源码这样实现这个算法 if ((e.hash & oldCap) == 0) {}else{}; 3.所以我们可以初始化hashmap的大小减少扩容次数提高效率。二、接下来我们再来分析一下get方法public V get(Object key) { Node e; return (e = getNode(hash(key), key)) == null ? null : e.value; } //获取key的hash，和存的时候获取的hash值一样。 static final int hash(Object key) {====================== int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } final Node getNode(int hash, Object key) { Node[] tab; Node first, e; int n; K k; //如果table不为null，并且长度大于0，并且 计算出的索引位置不为null; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { //检查一下这个索引下的第一个是否是需要的key if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { // 如果这个索引属于红黑树的话就去红黑树中获取，否则就遍历这个链表， //直到获取元素，如果没有就返回null。 if (first instanceof TreeNode) return ((TreeNode)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-08-20 06:33:46 "},"ji-he-xue-xi/map/linkedhashmap.html":{"url":"ji-he-xue-xi/map/linkedhashmap.html","title":"LinkedHashMap","keywords":"","body":"public class LinkedHashMap extends HashMap implements Map{ } ```java```Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/map/currenthashmap.html":{"url":"ji-he-xue-xi/map/currenthashmap.html","title":"CurrentHashMap","keywords":"","body":"我们知道HashMap不是线程安全的，因为两个线程同时操作一个hashMap的话，在1.7之前链表容易形成环，1.8以后还是存在不同线程之间的值进行覆盖的现象，会导致数据丢失；hashTable官方不建议使用，下边我们看一下CurrentHashMap的源码；static final int HASH_BITS = 0x7fffffff; static final int MOVED = -1; public V put(K key, V value) { return putVal(key, value, false); } static final int spread(int h) { return (h ^ (h >>> 16)) & HASH_BITS; } final V putVal(K key, V value, boolean onlyIfAbsent) { //如果key为null或者value为null,抛出异常 if (key == null || value == null) throw new NullPointerException(); // 得到hash的值 int hash = spread(key.hashCode()); int binCount = 0; //进入一个循环 for (Node[] tab = table;;) { Node f; int n, i, fh; //如果tab为null或者length长度为0，就初始化tab对象 if (tab == null || (n = tab.length) == 0) tab = initTable(); //如果计算出的索引位置为null的话进行cas赋值当前下标。如果失败的话说明有其它线程 在这一时刻给这个下标赋值，因此不会break，就会进入下个循环； else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node(hash, key, value, null))) break; // no lock when adding to empty bin } //如果当前下标的Node的hash值为-1 ，没看懂这里； else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { //f为当前下标的Node对象 V oldVal = null; //这里获取当前下表位置的头部对象锁 synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) {//fn指的是头部节点的hash值 //而且这个if里边做的链表的逻辑 //binCount 指的是链表的长度； binCount = 1; //遍历这个链表，如果链表中已存在相同的key，只用将值覆盖为最新的。 //否则，直到找到链表的尾部，将新的Node放到尾部 for (Node e = f;; ++binCount) { K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node pred = e; if ((e = e.next) == null) { pred.next = new Node(hash, key, value, null); break; } } } //如果f属于树的话，就往树里添加对象 else if (f instanceof TreeBin) { Node p; binCount = 2; if ((p = ((TreeBin)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } //如果走的链表的逻辑binCount的值为链表的长度， //如果走的是红黑树的逻辑binCount的值为固定值2， if (binCount != 0) { //如果binCount的值大于等于8，就变换成红黑树 if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/map/hong-hei-shu.html":{"url":"ji-he-xue-xi/map/hong-hei-shu.html","title":"红黑树","keywords":"","body":"//map的在put的时候存在一个将数组 //这是HashMap的红黑树源码。 final void treeifyBin(Node[] tab, int hash) { int n, index; Node e; //这里tab的长度小于64的话只进行扩容操作，没有做红黑树转换 if (tab == null || (n = tab.length) hd = null, tl = null; do { //根据链表的头部节点创建一个treeNode节点 TreeNode p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); //上边的do{}while() 语句将Node节点链表转换成TreeNode节点的链表 if ((tab[index] = hd) != null) hd.treeify(tab); } } TreeNode replacementTreeNode(Node p, Node next) { return new TreeNode<>(p.hash, p.key, p.value, next); } TreeNode(int hash, K key, V val, Node next) { super(hash, key, val, next); } //这里将treeNode的链表转换为红黑树; final void treeify(Node[] tab) { //红黑树的根部节点 TreeNode root = null; //这里的this指的是链表的头部；x指的是root节点 for (TreeNode x = this, next; x != null; x = next) { next = (TreeNode)x.next; x.left = x.right = null; //初始化root节点，颜色为黑色 if (root == null) { x.parent = null; x.red = false; root = x; } else { K k = x.key; int h = x.hash; Class kc = null; for (TreeNode p = root;;) { int dir, ph; K pk = p.key; //大于根节点的hash,放右边，小于放左边 if ((ph = p.hash) > h) dir = -1; else if (ph xp = p; if ((p = (dir Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"ji-he-xue-xi/map/treemap.html":{"url":"ji-he-xue-xi/map/treemap.html","title":"TreeMap","keywords":"","body":"TreeMap的底层是红黑树，而红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪。 具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：1.每个节点要么是红色，要么是黑色。 2.根节点必须是黑色 3.红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。 4.对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight） @Test public void main3(){ TreeMap treeMap = new TreeMap<>(); treeMap.put(\"1\", \"11\"); treeMap.put(\"2\", \"11\"); treeMap.put(\"3\", \"11\"); treeMap.put(\"4\", \"11\"); System.out.println(treeMap.get(\"2\")); } public TreeMap() { comparator = null; } public V put(K key, V value) { //第一次put的时候根节点root的值为null Entry t = root; if (t == null) { compare(key, key); // type (and possibly null) check //这个时候就初始化root节点 root = new Entry<>(key, value, null); size = 1; modCount++; return null; } int cmp; Entry parent; // split comparator and comparable paths //这个地方获取默认的comparator对象，因为在构造器中我们可以给comparator初始化自己的比较策略： //未初始化的话comparator对象为null Comparator cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp 0) t = t.right; else return t.setValue(value); } while (t != null); } else { //comparator为null的话需要保证key不为null; if (key == null) throw new NullPointerException(); @SuppressWarnings(\"unchecked\") Comparable k = (Comparable) key; // t为当前的节点，第一次循环为root根节点,一直循环到当前节点的最后子节点为null的时候， // 最后parent的值为子节点为null的节点; do { parent = t; //将新添加的key与当前遍历到的节点的key进行比较 cmp = k.compareTo(t.key); //小于走左边，大于走右边，等于覆盖当前节点的值； if (cmp 0) t = t.right; else return t.setValue(value); } while (t != null); } //最后再将新添加的key包装为Entry放到最后位置;这个时候新添加过程已经完成 Entry e = new Entry<>(key, value, parent); if (cmp 下边我们通过例子来分析fixAfterInsertion()方法 图 1.1 图 1.2 图1.3 //我们看到上图中，根节点是黑色，红色也不连续，当我们新加入15元素的时候 //x这里指的是新添加的元素 private void fixAfterInsertion(Entry x) { //新添加的元素的颜色为红色 x.color = RED; //由于15的父亲元素10为红色，因此会进入这个循环 while (x != null && x != root && x.parent.color == RED) { //如果新插入节点x的父节点是祖父节点的左孩子 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { //获取该节点的祖父的右子树 Entry y = rightOf(parentOf(parentOf(x))); //如果右子树为红色 if (colorOf(y) == RED) { //则将该节点的祖父节点的左右子书全部置为黑色，祖父节点的颜色置为红色 setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } else { if (x == rightOf(parentOf(x))) { x = parentOf(x); rotateLeft(x); } setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); } } else { //如果新插入节点x的父节点是祖父节点的右孩子 Entry y = leftOf(parentOf(parentOf(x))); //如果该节点的祖父节点的左子节点的颜色为红色 图1.1 if (colorOf(y) == RED) { //将该节点的父类节点全部置为黑色，并将祖父节点置为红色图1.2 setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } else { //如果该节点的祖父节点的左子树节点为黑色或者为null 如图1.3 新插入2的时候 if (x == leftOf(parentOf(x))) { x = parentOf(x); rotateRight(x); } setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); } } } //根节点一直为黑色 root.color = BLACK; } Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"./":{"url":"./","title":"1.2 Java.Current.Util笔记","keywords":"","body":"gitbook文档Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2019-04-23 06:39:13 "},"aqskuang-jia-xue-xi.html":{"url":"aqskuang-jia-xue-xi.html","title":"AQS-ReentrantLock","keywords":"","body":"AQS类图结构ReentrantLock类图结构一般我们在程序中这样使用reentrantLock对象public class AQS { private static final ReentrantLock reentrantLock = new ReentrantLock(true); public void work(){ reentrantLock.lock(); try { Thread currentThread = Thread.currentThread(); System.out.println(currentThread.getName() +\"执行任务\"); TimeUnit.SECONDS.sleep(5); } catch (Exception e) { e.printStackTrace(); }finally { reentrantLock.unlock(); } } } abstract static class Sync extends AbstractQueuedSynchronizer public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 首先当我们调用new ReentrantLock()时，构造器中给我们返回了NonfairSync非公平锁对象或者是公平锁对象FairSync;然后我们调用lock()方法。接下来我们再来看lock的源码：public void lock() { sync.lock(); } static final class FairSync extends Sync { final void lock() { acquire(1); } //首先进入的是这个方法，当tryAcquire 返回true的时候那么整个lock流程也就结束了。 //假设两个线程T1和T2先后进入lock方法，t1正常情况下tryAcquire返回true，接下来我们来看tryAcquire源码。 public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } } protected final boolean tryAcquire(int acquires) { //获取当前线程 final Thread current = Thread.currentThread(); //获取锁的state的值 int c = getState(); //当state==0时也就是初始化状态。 if (c == 0) { //t1线程走到这里，正常情况下前一个判断返回的是false,接下来就会进行CAS对state的值进行加1操作。 //如果CAS成功的话返回true那么FairSync的属性exclusiveOwnerThread的值就是当前获取到锁的线程,也就是t1。 //FairSync的state的值经过CAS操作已经变为1了。现在我们来看一下这个判断条里的三个方法。 if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //如果FairSync的state不等于0的话再判断一下当前线程是否已经获取过锁了， //如果已经或去过那么就state+1，这也就是重入锁。返回true； else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc t1线程获取完锁以后接下来我们来分析t2线程，现在再次回到之前的方法。public final void acquire(int arg) { //t2线程此时也走到这里。同样先进入tryAcquire方法。 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } protected final boolean tryAcquire(int acquires) { //同样获取当前线程 T2 final Thread current = Thread.currentThread(); //获取T2线程的state的值，此时获取的state的值大于0 我们之前分析过T1， //T1线程获取完线程以后会将state的值通过cas方式加1操作， //如果是重入的话进行累加操作，每获取一次就累加。所以这个方法会返回false; int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 0 //前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点： //进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。 //所以下面这块代码说的是将当前节点的prev指向waitStatus 0) { do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { //如果前驱结点的值为0，就将前驱结点的值设置为-1; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } //由于shouldParkAfterFailedAcquire和parkAndCheckInterrupt是在一个循环中，所以第二次循环的话 //shouldParkAfterFailedAcquire会返回true,最后挂起当前线程。 private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } # 二 、唤醒操作 public void unlock() { sync.release(1); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //如果c==0 也就是没有重入锁了就直接完全释放。 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } //入参是head节点 private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ //获取头部节点的status值如果小于0的话通过cas操作将值设置为0 int ws = node.waitStatus; if (ws 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus 当存在T2,T3线程的时候FairSync对象所维护的链表如图所示,总结 ： 1.锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁， 可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了， 如果锁重入的话，state进行+1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁， 所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。2.线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。 3.阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待， 这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表， 每个 node 都持有后继节点的引用。 Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"aqs-condition.html":{"url":"aqs-condition.html","title":"AQS-Condition","keywords":"","body":" /** * Created by sukang on 2018/7/26. */ public class ThreadNotifyTest{ /** * 定义一个volatile变量 */ private static volatile int num = 0; private static Object lock = new Object(); private static ReentrantLock reentrantLock = new ReentrantLock(true); private static Condition condition = reentrantLock.newCondition(); @Test public void main3() throws Exception{ Thread thread = new Thread(new Runnable() { @Override public void run() { reentrantLock.lock(); while (num != 1){ try { System.out.println(\"不满足条件线程进入_WaitSet\"); condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"满足条件，线程进入_EntryList\"); } },\"BB\"); //线程A获取锁不满足条件进入等待队列 thread.start(); //为了保证线程A获取锁成功主线程先sleep TimeUnit.SECONDS.sleep(2); //线程A调用wait方法释放锁,主线程获取锁之后进行通知 num = 1; reentrantLock.lock(); //通知_WaitSet队列里的线程 condition.signal(); System.out.println(\"通知_WaitSet队列\"); //释放锁，然后让_WaitSet队列的线程再次获取锁 reentrantLock.unlock(); } /** *这种方式是通过Object的wait方法和notify方法来实现的 *wait()、notify()是和synchronized配合使用的，因此如果使用了显示锁Lock，就不能用了。 *所以显示锁要提供自己的等待/通知机制，Condition应运而生。 */ @Test public void main2() throws Exception{ Thread thread = new Thread(new Runnable() { @Override public void run() { synchronized (lock){ while (num != 1){ try { System.out.println(\"不满足条件线程进入_WaitSet\"); lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"满足条件，线程进入_EntryList\"); } } },\"A\"); //线程A获取锁不满足条件进入等待队列 thread.start(); //为了保证线程A获取锁成功主线程先sleep TimeUnit.SECONDS.sleep(2); //线程A调用wait方法释放锁,主线程获取锁之后进行通知 num = 1; synchronized (lock){ //通知_WaitSet队列里的线程 lock.notify(); System.out.println(\"通知_WaitSet队列\"); } } /** *自旋实现的等待通知 *最简单的实现方法就是将condition设为一个volatile的变量当A线程检测到条件不满足时就自旋 *这种方式的问题在于自旋非常耗费CPU资源，当然如果在自旋的代码块里加入Thread.sleep(time) *将会减轻CPU资源的消耗，但是如果time设的太大，A线程就不能及时响应condition的变化，如果设的太小， *依然会造成CPU的消耗,因此我们可以改进通过notify来. * * *notifyAll：使所有获取过本锁对象的等待的线程统统退出wait的状态: * *notyfy :notify则文明得多他只是选择一个wait状态线程进行通知，并使它获得该对象上的锁， 但不惊动其他同样在等待被该对象notify的线程 *此时其它在等待队列的线程还是处于等待状态 * / @Test public void main1() throws Exception{ Thread thread = new Thread(new Runnable() { @Override public void run() { while (num != 1){ System.out.println(\"不满足条件\"); } System.out.println(\"满足条件退出\"); } }); thread.start(); TimeUnit.SECONDS.sleep(2); num =1; } } //接下来我们看看Condition的实现源码 /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); //调用await的线程，首先进入addConditionWaiter方法 Node node = addConditionWaiter(); //这里将线程获取的锁完全释放 int savedState = fullyRelease(node); //判断当前线程是否还在wait队列中，如果存在就挂起线程。 int interruptMode = 0; while (!isOnSyncQueue(node)) { LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) && interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } private Node addConditionWaiter() { Node t = lastWaiter; // 如果队列的尾部状态不是-2的话就将该Node从等待队列移除。 if (t != null && t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //将当前线程包装成Node对象添加到队列尾部，node状态为-2 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } //下边是释放当前线程占有的锁的源码 final int fullyRelease(Node node) { boolean failed = true; try { //获取lock对象的锁状态 int savedState = getState(); if (release(savedState)) { failed = false; return savedState; } else { throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } } // public final boolean release(int arg) { if (tryRelease(arg)) { //获取锁的等待队列的头部对象 Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //获取当前锁的锁状态，这时c为0 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; //将锁属于的线程设置为null setExclusiveOwnerThread(null); } 将锁状态这是为0 setState(c); return free; } //接下来看通知代码 public final void signal() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } // private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; } while (!transferForSignal(first) && (first = firstWaiter) != null); } final boolean transferForSignal(Node node) { /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ Node p = enq(node); int ws = p.waitStatus; if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; } Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-09 08:49:34 "},"aqs-countdownlantch.html":{"url":"aqs-countdownlantch.html","title":"AQS-CountDownLatch","keywords":"","body":"//我们先看一个例子 public static void main(String[] args){ CountDownLatch latch = new CountDownLatch(2); new Thread(() -> { try { TimeUnit.SECONDS.sleep(5); } catch (Exception e) { e.printStackTrace(); } latch.countDown(); },\"T1\").start(); new Thread(() -> { try { TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } // 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown() latch.countDown(); }, \"T2\").start(); new Thread(() -> { try { // 阻塞，等待 state 减为 0 latch.await(); System.out.println(\"线程 t3 从 await 中返回了\"); } catch (InterruptedException e) { System.out.println(\"线程 t3 await 被中断\"); Thread.currentThread().interrupt(); e.printStackTrace(); } }, \"T3\").start(); new Thread(() -> { try { // 阻塞，等待 state 减为 0 latch.await(); System.out.println(\"线程 t4 从 await 中返回了\"); } catch (InterruptedException e) { System.out.println(\"线程 t4 await 被中断\"); Thread.currentThread().interrupt(); e.printStackTrace(); } }, \"T4\").start(); } //上边例子中有4个线程，T1和T2调用countDown方法将state的值进行减一操作， //T3,T4线程调用await方法，线程进入阻塞等待state的值减到0为止，然后T3,T4唤醒继续走. 一# 等待分析 public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); //如果state的值 >0 则进入doAcquireSharedInterruptibly方法 if (tryAcquireShared(arg) = 0) { setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; } } //shouldParkAfterFailedAcquire()将当前节点的前一个的state值设置为-1 //然后进入parkAndCheckInterrupt 方法线程挂起 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } //ReentrantLock的addWaiter传入的是null，这里传入的是new的空Node对象,我们将其命名为Node-shared. private Node addWaiter(Node mode) { //这里将当前线程包装为Node,我们把它命名为Node-1,next为Node-shared Node node = new Node(Thread.currentThread(), mode); Node pred = tail; //如果tail不为null，将新包装的Node直接加入队列 if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } //参数为Node-1 private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 二、唤醒分析 public void countDown() { sync.releaseShared(1); } public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { //只有减一操作后的state的值为0，才会进入这个方法 doReleaseShared(); return true; } return false; } //这个方法是采用子旋的方式将state的值减一操作 protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { //获取state的值 int c = getState(); //如果state直接等于0,说明不能进行减一操作直接返回. if (c == 0) return false; int nextc = c-1; //进行cas将减一后的值重新赋值，如果失败说明有另外线程已经赋值， //所以进入下一个循环 if (compareAndSetState(c, nextc)) return nextc == 0; } } private void doReleaseShared() { for (;;) { Node h = head; if (h != null && h != tail) { //拿到head节点的status，因为T3入队的时候将head的status设置为-1了 int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } } 三# 总结 1.AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值， 所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作， 当 state 减到 0 的同时，那个线程会负责唤醒调用了 await 方法的所有线程Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"aqs-semaphore.html":{"url":"aqs-semaphore.html","title":"AQS-Semaphore","keywords":"","body":"1.Semaphore也是两个构造器，分别返回公平锁对象或者是非公平锁对象 2.创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的， 然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1， 当然，调用acquire 的时候，如果 state = 0，说明没有资源了就需要去排队，需要等待其他线程 release。 public Semaphore(int permits, boolean fair) { sync = fair ? new FairSync(permits) : new NonfairSync(permits); } public Semaphore(int permits) { sync = new NonfairSync(permits); } 1.acquire分析 public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) = 0) { setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 2.我们看释放资源操作 public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } //CAS将资源的值加一操作 protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); int next = current + releases; if (next Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "},"linkedblockingqueue.html":{"url":"linkedblockingqueue.html","title":"LinkedBlockingQueue","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-12-25 05:21:54 "},"leetcode.html":{"url":"leetcode.html","title":"1.3 LeetCode","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-09 08:49:34 "},"leetcode/shu-zu.html":{"url":"leetcode/shu-zu.html","title":"数组","keywords":"","body":"一。 /**给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1: 输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3 解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。 同时, 3 也是第一个符合要求的中心索引。 **/ Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-09 08:49:34 "},"leetcode/lian-biao.html":{"url":"leetcode/lian-biao.html","title":"链表","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-09 08:49:34 "},"leetcode/680826-dui-lie.html":{"url":"leetcode/680826-dui-lie.html","title":"栈&队列","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-09 08:49:34 "},"leetcode/hash.html":{"url":"leetcode/hash.html","title":"Hash","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-09 08:49:34 "},"nginx.html":{"url":"nginx.html","title":"1.4 Nginx","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-15 08:04:56 "},"nginx/locationpi-pei-gui-ze.html":{"url":"nginx/locationpi-pei-gui-ze.html","title":"location匹配规则","keywords":"","body":"location匹配规则分为普通匹配和正则匹配 语法为：location [=|~|~*|^~] /uri/ { … }1.正则匹配 “~ ”和“~ ”前缀表示正则location ，“~ ”区分大小写，“~ ”不区分大小写;2.普通匹配 前缀（包括：“=”，“^~ ”和“@ ”）和无任何前缀的都属于普通location;1.nginx 先匹配普通location再匹配正则location。如果有正则匹配上就使用正则匹配，如果正则没有匹配上就使用普通location 2.我们也可以让nginx匹配到了普通location不再去搜索正则location。可以在前边添加 ^~ 或者= 符号，这两个符号都可以让nginx 匹配完普通location后不再去匹配正则location。 = 和^~的区别是 = 是全值匹配^~是最左前缀 3.但其实还有一种“隐含”的方式来阻止正则location 的搜索，这种隐含的方式就是：当“最大前缀”匹配恰好就是一个“严格精确（exact match ）”匹配， 照样会停止后面的搜索。普通location的严格精确匹配>正则匹配>普通的非严格精确匹配测试： L1: location / { deny all; } L2: location ~ \\.html$ { root html; allow all; } http://127.0.0.1:8080/ 403 Forbidden http://127.0.0.1:8080/index.html Welcome to nginx! http://127.0.0.1:8080/inde.html 404 Not Found 分析： 第一个url严格精确匹配到L1 因此不会再去匹配正则 所以走L1； 第二个url 第一步先匹配到L1并且L1没有=或者^~符合 因此还会去匹配正则L2; 第三个url和第二个url同理; L1: location ^~ / { deny all; } L2: location ~ \\.html$ { root html; allow all; } http://127.0.0.1:8080/ 403 Forbidden http://127.0.0.1:8080/index.html 403 Forbidden http://127.0.0.1:8080/indx.html 403 Forbidden 由于普通location L1 有^~符号 因此3个url都满足最左前缀匹配到L1，并且不会再去匹配正则； L1: location = / { deny all; } L2: location ~ \\.html$ { root html; allow all; } http://127.0.0.1:8080/ 403 Forbidden http://127.0.0.1:8080/index.html Welcome to nginx! http://127.0.0.1:8080/indx.html 404 Not Found 这次L1用=修饰 只有第一个url完全匹配L1，第二个和第三个不满足完全匹配因此还会搜索正则匹配； location ^~ / { deny all; } location /hello { root html; allow all; } location ~ \\.html$ { root html; allow all; } http://127.0.0.1:8080/ 403 http://127.0.0.1:8080/index.html 403 http://127.0.0.1:8080/hello/index.html 404 第一个和第二个url都在普通location中找到了L1 并且L1 用了^~ 修饰 不再去匹配正则location 第三个url先命中L2,L2没有任何修饰，然后再去匹配正则location location ^~ / { deny all; } location /hello/index.html { root html; allow all; } location /hello { root html; deny all; } http://127.0.0.1:8080/ 403 http://127.0.0.1:8080/index.html 403 http://127.0.0.1:8080/hello/index.html 404 http://127.0.0.1:8080/hello 403 http://127.0.0.1:8080/hello/inde.html 403 第一个和第二个url都先匹配到L1普通location 不再去匹配正则； 第3个url精确匹配到L2 第4个url精确匹配到L3 第5个url最左前缀命中到L3 •正则location的匹配是按照编辑的先后顺序进行匹配，匹配后不再继续遍历剩余的正则location。Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-11-15 08:04:56 "},"framework.html":{"url":"framework.html","title":"1.5 FrameWork","keywords":"","body":"Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2019-08-13 03:37:21 "},"framework/mybatis.html":{"url":"framework/mybatis.html","title":"Mybatis","keywords":"","body":"http://www.mybatis.org/spring/zh/index.htmlhttp://www.mybatis.org/mybatis-3/zh/index.html private static final String DRIVER_CLASS = \"com.mysql.jdbc.Driver\"; private static final String DATA_URL = \"\"; private static final String USER_AME = \"\"; private static final String DATA_PASSWORD = \"\"; public static void main(String[] args) { Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try { Class.forName(DRIVER_CLASS); connection = DriverManager.getConnection(DATA_URL, USER_AME, DATA_PASSWORD); preparedStatement = connection .prepareStatement( \" SELECT * FROM schedule_job WHERE is_delete = ? \"); preparedStatement.setInt(1,0); resultSet = preparedStatement.executeQuery(); StringBuilder stringBuilder = new StringBuilder(); while (resultSet.next()){ stringBuilder.append(resultSet.getString(\"bean_name\")); stringBuilder.append(\"--\"); stringBuilder.append(resultSet.getString(\"method_name\")); stringBuilder.append(\"\\n\"); } System.out.println(stringBuilder.toString()); } catch (Exception e) { e.printStackTrace(); } finally { if (resultSet != null){ try { resultSet.close(); }catch (Exception e){ e.printStackTrace(); } } if (preparedStatement != null){ try { preparedStatement.close(); }catch (Exception e){ e.printStackTrace(); } } if (connection != null){ try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } // mybatis 运行原理以及流程 DefaultTransactionDefinition def = new DefaultTransactionDefinition(); PlatformTransactionManager txManager = new DataSourceTransactionManager(dataSource); TransactionStatus status = txManager.getTransaction(def); try { //get jdbc connection... //execute sql... } catch (Exception e) { txManager.rollback(status); throw e; } txManager.commit(status); Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2019-08-13 03:37:21 "},"logback.html":{"url":"logback.html","title":"2 LogBack配置文件","keywords":"","body":" %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n appender的属性1.name指定&lt;appender&gt;的名称 2.class指定&lt;appender&gt;的全限定名 Copyright © sukang 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-25 03:13:22 "}}